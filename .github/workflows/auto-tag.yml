name: Auto Tag

on:
  push:
    branches:
      - main
  
  # Permitir acionamento manual atrav√©s da interface do GitHub
  workflow_dispatch:
    inputs:
      version_increment:
        description: 'Tipo de incremento de vers√£o'
        required: true
        default: 'patch'
        type: choice
        options:
        - patch
        - minor
        - major

jobs:
  auto-tag:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    
    steps:
      - name: Checkout c√≥digo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Necess√°rio para obter todas as tags
          ref: main # Garantir que estamos na branch main
      
      - name: Configurar Git
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
      
      - name: Determinar incremento de vers√£o
        id: increment_type
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "type=${{ github.event.inputs.version_increment }}" >> $GITHUB_OUTPUT
          else
            # Analisar a mensagem do commit para decidir o tipo de incremento
            COMMIT_MSG=$(git log -1 --pretty=%B)
            if [[ $COMMIT_MSG == *"#major"* ]]; then
              echo "type=major" >> $GITHUB_OUTPUT
            elif [[ $COMMIT_MSG == *"#minor"* ]]; then
              echo "type=minor" >> $GITHUB_OUTPUT
            else
              echo "type=patch" >> $GITHUB_OUTPUT
            fi
          fi
      
      - name: Obter √∫ltima tag
        id: get_tag
        run: |
          # Buscar todas as tags remotas
          git fetch --tags --force
          
          # Listar todas as tags para debug
          echo "Todas as tags dispon√≠veis:"
          git tag -l | sort -V
          
          # Obter a √∫ltima tag de vers√£o (formato vX.Y.Z)
          LATEST_TAG=$(git tag -l "v[0-9]*.[0-9]*.[0-9]*" | sort -V | tail -n 1)
          
          # Caso n√£o exista nenhuma tag, come√ßar com v0.0.0
          if [ -z "$LATEST_TAG" ]; then
            LATEST_TAG="v0.0.0"
            echo "Nenhuma tag de vers√£o encontrada, come√ßando com $LATEST_TAG"
          else
            echo "√öltima tag de vers√£o encontrada: $LATEST_TAG"
          fi
          
          echo "latest_tag=$LATEST_TAG" >> $GITHUB_OUTPUT
          
          # Extrair componentes da vers√£o (remover o "v" inicial e dividir por pontos)
          VERSION=${LATEST_TAG#v}
          MAJOR=$(echo $VERSION | cut -d. -f1)
          MINOR=$(echo $VERSION | cut -d. -f2)
          PATCH=$(echo $VERSION | cut -d. -f3)
          
          echo "major=$MAJOR" >> $GITHUB_OUTPUT
          echo "minor=$MINOR" >> $GITHUB_OUTPUT
          echo "patch=$PATCH" >> $GITHUB_OUTPUT
      
      - name: Calcular nova vers√£o
        id: new_version
        run: |
          MAJOR=${{ steps.get_tag.outputs.major }}
          MINOR=${{ steps.get_tag.outputs.minor }}
          PATCH=${{ steps.get_tag.outputs.patch }}
          
          case "${{ steps.increment_type.outputs.type }}" in
            major)
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            minor)
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            patch)
              PATCH=$((PATCH + 1))
              ;;
          esac
          
          NEW_TAG="v${MAJOR}.${MINOR}.${PATCH}"
          echo "version=$NEW_TAG" >> $GITHUB_OUTPUT
          echo "version_without_v=${MAJOR}.${MINOR}.${PATCH}" >> $GITHUB_OUTPUT
      
      - name: Atualizar README com nova vers√£o (se existir)
        run: |
          if grep -q "Version:" README.md; then
            sed -i "s/Version: .*/Version: ${{ steps.new_version.outputs.version_without_v }}/" README.md
            git add README.md
          fi
          
          if grep -q "Vers√£o:" README.pt-BR.md 2>/dev/null; then
            sed -i "s/Vers√£o: .*/Vers√£o: ${{ steps.new_version.outputs.version_without_v }}/" README.pt-BR.md
            git add README.pt-BR.md
          fi
      
      - name: Criar commit para atualiza√ß√£o de vers√£o
        id: commit_version
        run: |
          CHANGES_MADE=$(git status --porcelain | wc -l)
          if [ "$CHANGES_MADE" -gt "0" ]; then
            git commit -m "Atualizar vers√£o para ${{ steps.new_version.outputs.version }}"
            echo "changes_made=true" >> $GITHUB_OUTPUT
          else
            echo "changes_made=false" >> $GITHUB_OUTPUT
          fi
      
      - name: Enviar altera√ß√µes ao reposit√≥rio
        if: steps.commit_version.outputs.changes_made == 'true'
        run: git push
      
      - name: Criar tag
        run: |
          # Verificar se a tag j√° existe
          if git rev-parse "${{ steps.new_version.outputs.version }}" >/dev/null 2>&1; then
            echo "‚ö†Ô∏è ATEN√á√ÉO: A tag ${{ steps.new_version.outputs.version }} j√° existe!"
            echo "Para corrigir isso, voc√™ pode:"
            echo "1. Remover a tag existente: git tag -d ${{ steps.new_version.outputs.version }} && git push origin :refs/tags/${{ steps.new_version.outputs.version }}"
            echo "2. Ou incrementar manualmente para a pr√≥xima vers√£o"
            exit 1
          fi
          
          echo "üè∑Ô∏è Criando tag ${{ steps.new_version.outputs.version }}..."
          git tag -a ${{ steps.new_version.outputs.version }} -m "Release ${{ steps.new_version.outputs.version }}"
          
          echo "üì§ Enviando tag para o reposit√≥rio remoto..."
          git push origin ${{ steps.new_version.outputs.version }}
      
      - name: Verificar workflow de build
        run: |
          echo "‚è≥ Aguardando o in√≠cio do workflow de build..."
          sleep 10  # Dar tempo para o webhook da tag ser processado
          
          # Tentar obter o status do workflow de build
          WORKFLOW_STATUS=$(curl -s \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/actions/workflows/build.yml/runs?event=push&branch=${{ steps.new_version.outputs.version }}" | 
            jq -r '.workflow_runs[0].status')
            
          echo "Status do workflow de build: ${WORKFLOW_STATUS:-n√£o encontrado}"
            
      - name: Resumo da vers√£o
        run: |
          echo "üéâ Nova vers√£o criada: ${{ steps.new_version.outputs.version }}"
          echo "üè∑Ô∏è Tipo de incremento: ${{ steps.increment_type.outputs.type }}"
          echo "üîó Release ser√° criada em: https://github.com/${{ github.repository }}/releases/tag/${{ steps.new_version.outputs.version }}"
          echo ""
          echo "Importante: Voc√™ pode verificar o progresso do build em:"
          echo "https://github.com/${{ github.repository }}/actions/workflows/build.yml"
